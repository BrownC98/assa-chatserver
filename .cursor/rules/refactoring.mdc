---
description: 
globs: 
alwaysApply: true
---
# ASSA Chat Server 1일 리팩토링 Rules

## 프로젝트 개요
- **목적**: 안드로이드 앱용 실시간 채팅 소켓 서버 및 WebRTC 시그널링 서버
- **규모**: 포트폴리오용 (동시 접속자 10명 내외)
- **기술스택**: Java 20, Maven, MySQL, Log4j2, Gson, Socket API (기존 유지)
- **리팩토링 목표**: User 클래스(757줄)를 3개 핸들러로 분리
- **시간 제약**: 1일(8시간) 내 완료

## 1일 리팩토링 핵심 원칙

### 1. 시간 제약 하의 TDD 적용
- 기존 JUnit 4.11 활용한 최소한의 테스트 작성
- 핵심 기능 보호용 통합 테스트 우선
- Red-Green-Refactor 사이클을 빠르게 적용

### 2. 기존 기능 100% 유지
- 새로운 기능 추가 완전 금지
- 컴파일 에러 없는 점진적 분리
- 각 단계마다 테스트 실행 및 검증

### 3. 실용적 구조 개선
- User 클래스를 3개 핸들러로 분리:
  - UserConnectionManager: 연결 관리 (1순위)
  - MessageHandler: 메시지 처리 (2순위)  
  - WebRTCSignalingHandler: WebRTC 시그널링 (3순위)
- 완벽함보다는 동작하는 개선 우선

## 코딩 스타일 및 컨벤션

### 1. 네이밍 컨벤션
- **클래스명**: PascalCase (예: `MessageHandler`, `UserConnectionManager`)
- **메서드명**: camelCase (예: `handleMessage`, `processConnection`)
- **상수명**: UPPER_SNAKE_CASE (예: `MAX_MESSAGE_LENGTH`, `CONNECTION_TIMEOUT`)
- **패키지명**: 소문자 + 점 표기법 (예: `com.teamnova.connection`)

### 2. 메서드 및 클래스 크기 제한 (1일 목표)
- **메서드**: 최대 50줄, 매개변수 5개 이내
- **User 클래스**: 757줄 → 400줄 이하 (최소 목표), 200줄 이하 (이상적 목표)
- **새 핸들러 클래스**: 각각 200줄 이내
- **중첩 if문**: 3단계 이내

### 3. 예외 처리 표준
```java
// 모든 public 메서드에 적절한 예외 처리
public void handleMessage(String message) {
    log.debug("handleMessage() - START: message={}", message);
    try {
        // 비즈니스 로직
    } catch (SpecificException e) {
        log.error("메시지 처리 실패: {}", e.getMessage(), e);
        throw new MessageProcessingException("메시지 처리 중 오류 발생", e);
    } finally {
        log.debug("handleMessage() - END");
    }
}
```

## 1일 리팩토링 클래스 구조

### 분리할 핵심 클래스 (1일 목표)
```java
// 1순위: UserConnectionManager
public class UserConnectionManager {
    private Socket socket;
    private boolean isConnected;
    
    public void replaceSocket(Socket newSocket) { /* 기존 로직 */ }
    public boolean isConnected() { /* 기존 로직 */ }
    public void disconnect() { /* 기존 로직 */ }
}

// 2순위: MessageHandler  
public class MessageHandler {
    private User user;
    private DBHelper dbHelper;
    
    public void sendMessage(String message) { /* 기존 로직 */ }
    public void checkReceive() { /* 기존 로직 */ }
    public void createRoom(String roomName) { /* 기존 로직 */ }
}

// 3순위: WebRTCSignalingHandler
public class WebRTCSignalingHandler {
    private User user;
    
    public void createVideoRoom(String roomId) { /* 기존 로직 */ }
    public void handleSDP(String sdp) { /* 기존 로직 */ }
    public void handleIceCandidate(String candidate) { /* 기존 로직 */ }
}

// 수정된 User 클래스 (위임 패턴)
public class User extends Thread {
    // 기본 사용자 정보
    private String userId;
    private String userName;
    
    // 핸들러들
    private UserConnectionManager connectionManager;
    private MessageHandler messageHandler;
    private WebRTCSignalingHandler webrtcHandler;
    
    // 생성자에서 핸들러 초기화
    public User(Socket socket) {
        this.connectionManager = new UserConnectionManager(socket);
        this.messageHandler = new MessageHandler(this);
        this.webrtcHandler = new WebRTCSignalingHandler(this);
    }
    
    // 기존 메서드들은 해당 핸들러로 위임
    public void sendMessage(String msg) {
        messageHandler.sendMessage(msg);
    }
}
```

### 패키지 구조 (1일 후 상태)
```
com.teamnova
├── User.java (경량화됨)
├── UserConnectionManager.java (신규)
├── MessageHandler.java (신규)
├── WebRTCSignalingHandler.java (신규)
├── ChatServer.java (기존 유지)
├── DBHelper.java (기존 유지)
├── command/ (기존 유지)
├── dto/ (기존 유지)
└── utils/ (기존 유지)
```

## TDD 적용 가이드

### 1. TDD 사이클
```
1. Red: 실패하는 테스트 작성
2. Green: 테스트를 통과하는 최소 코드 작성
3. Refactor: 코드 개선 (테스트 유지)
4. Repeat: 다음 기능으로 반복
```

### 2. 테스트 작성 우선순위
1. **통합 테스트**: 기존 기능 보호용 (리팩토링 전 작성)
2. **단위 테스트**: 새로 분리된 클래스별 (리팩토링 중 작성)
3. **리그레션 테스트**: 기능 손실 방지용

### 3. 테스트 작성 방법
```java
// JUnit 4.11 활용한 테스트 작성
@Test
public void givenValidMessage_whenSendMessage_thenMessageSentSuccessfully() {
    // Given: 테스트 데이터 준비
    // When: 테스트 대상 메서드 실행
    // Then: 결과 검증
}
```

### 4. 테스트 네이밍 컨벤션
- Given_When_Then 패턴 사용
- 테스트 의도가 명확하게 드러나는 이름
- 한글 주석으로 테스트 목적 설명

## 로깅 표준

### 1. 로그 레벨 사용 기준
- **DEBUG**: 메서드 진입/종료, 상세 실행 과정
- **INFO**: 중요한 비즈니스 이벤트 (사용자 연결, 메시지 전송)
- **WARN**: 예상 가능한 문제 상황
- **ERROR**: 예외 상황, 시스템 오류

### 2. 로그 메시지 포맷
```java
// 메서드 시작
log.debug("methodName() - START: param1={}, param2={}", param1, param2);

// 중요 이벤트
log.info("사용자 연결: userId={}, socketAddress={}", userId, socket.getRemoteSocketAddress());

// 에러 로그
log.error("메시지 전송 실패: userId={}, error={}", userId, e.getMessage(), e);

// 메서드 종료
log.debug("methodName() - END: result={}", result);
```

## 구조 개선 가이드

### 1. 메모리 관리 (기존 기술 활용)
- 현재 `LinkedList<String>` 구조 유지하되 사용 방식 개선
- 불필요한 객체 생성 최소화
- 기존 컬렉션 타입의 효율적 활용

### 2. 동시성 처리 (기존 방식 유지)
- `ConcurrentHashMap` 활용 유지
- `synchronized` 블록 최적화
- 데드락 방지를 위한 일관된 락 순서

### 3. 데이터베이스 처리 (기존 구조 유지)
- 현재 DBHelper 싱글톤 패턴 유지
- PreparedStatement 재사용 최적화
- 기존 Connection 관리 방식 개선

## 1일 리팩토링 타임라인 (8시간)

### Phase 1: 준비 및 분석 (1시간) - 09:00~10:00
- [ ] 현재 User 클래스 분석 및 분리 지점 파악
- [ ] 기본 테스트 환경 확인 (JUnit 4.11)
- [ ] 백업 생성 (Git commit)
- [ ] 분리할 메서드 목록 작성

### Phase 2: 핵심 테스트 작성 (1.5시간) - 10:00~11:30
- [ ] 기존 기능 보호용 통합 테스트 작성
  - [ ] 사용자 연결/해제 테스트
  - [ ] 메시지 송수신 테스트
  - [ ] WebRTC 기본 시그널링 테스트
- [ ] 테스트 실행 및 현재 상태 확인

### Phase 3: UserConnectionManager 분리 (1.5시간) - 11:30~13:00
- [ ] 연결 관리 관련 메서드 분리
  - [ ] replaceSocket()
  - [ ] 소켓 상태 관리 로직
  - [ ] 연결 해제 처리
- [ ] User 클래스에서 ConnectionManager 사용하도록 수정
- [ ] 테스트 실행 및 검증

### 점심시간 (1시간) - 13:00~14:00

### Phase 4: MessageHandler 분리 (2시간) - 14:00~16:00
- [ ] 메시지 처리 관련 메서드 분리
  - [ ] SendMessage()
  - [ ] checkReceive()
  - [ ] createRoom(), roomInfo(), roomExit()
- [ ] User 클래스에서 MessageHandler 사용하도록 수정
- [ ] 테스트 실행 및 검증

### Phase 5: WebRTCSignalingHandler 분리 (1.5시간) - 16:00~17:30
- [ ] WebRTC 관련 메서드 분리
  - [ ] createVideoRoom(), joinVideoRoom()
  - [ ] handleSDP(), handleIceCandidate()
  - [ ] mediaStatus() 관련 로직
- [ ] User 클래스에서 WebRTCHandler 사용하도록 수정
- [ ] 테스트 실행 및 검증

### Phase 6: 최종 정리 및 검증 (0.5시간) - 17:30~18:00
- [ ] 전체 테스트 실행
- [ ] 코드 정리 (import, 주석)
- [ ] 최종 커밋

## 코드 리뷰 체크리스트

### 기능성
- [ ] 기존 기능이 정상 동작하는가?
- [ ] 새로운 버그가 발생하지 않았는가?
- [ ] 테스트가 모든 케이스를 커버하는가?

### 구조
- [ ] 단일 책임 원칙을 준수하는가?
- [ ] 클래스 간 결합도가 낮은가?
- [ ] 패키지 구조가 논리적인가?

### 품질
- [ ] 메서드 길이가 50줄 이내인가?
- [ ] 변수명이 의미를 명확히 전달하는가?
- [ ] 적절한 예외 처리가 되어 있는가?

### 성능
- [ ] 메모리 누수 가능성이 없는가?
- [ ] 동시성 처리가 안전한가?
- [ ] 불필요한 객체 생성이 없는가?

## 1일 리팩토링 성공 기준

### 최소 성공 기준 (반드시 달성)
- [ ] User 클래스 크기 50% 이상 축소 (757줄 → 400줄 이하)
- [ ] 최소 1개 핸들러 분리 완료 (UserConnectionManager 우선)
- [ ] 기존 기능 100% 동작
- [ ] 컴파일 에러 없음

### 이상적 성공 기준 (목표)
- [ ] 3개 핸들러 모두 분리 완료
- [ ] User 클래스 200줄 이하로 축소
- [ ] 핵심 테스트 5개 이상 작성
- [ ] 코드 정리 완료

## 리스크 관리

### 시간 부족 시 우선순위
1. **1순위**: UserConnectionManager 분리 (가장 독립적)
2. **2순위**: MessageHandler 분리 (핵심 기능)
3. **3순위**: WebRTCSignalingHandler 분리 (선택적)

### 문제 발생 시 대응
- **컴파일 에러**: 즉시 이전 단계로 롤백
- **테스트 실패**: 해당 기능만 원복 후 다음 단계 진행
- **시간 초과**: 완료된 부분만 커밋하고 나머지는 다음 기회에

## 금지 사항 (1일 리팩토링)

### 1. 새로운 기능 구현 완전 금지
- 새로운 기능 추가 금지
- 새로운 라이브러리 추가 금지 (기존 JUnit 4.11만 사용)
- 새로운 프레임워크 도입 금지
- 기존 기능 스펙 변경 금지

### 2. 시간 낭비 요소 금지
- 완벽한 패키지 구조 재정리 금지
- 과도한 테스트 작성 금지
- 코드 스타일 완벽화 금지
- 문서화 작업 최소화

### 3. 위험한 변경 금지
- 한 번에 여러 클래스 동시 수정
- 기존 API 인터페이스 변경
- 데이터베이스 스키마 변경
- 리소스 누수 위험 작업

## 1일 리팩토링 완료 후 다음 단계

### 추가 개선 사항 (별도 일정)
- 더 세밀한 단위 테스트 작성
- 예외 처리 개선
- 로깅 시스템 개선
- 성능 최적화

### 장기 계획
- 패키지 구조 재정리
- 디자인 패턴 적용
- 문서화 개선

---

**목표**: 1일 8시간 내 User 클래스 분리를 통한 유지보수성 향상  
**핵심**: 기존 기능 유지 + 안전한 구조 개선  
**도구**: 기존 JUnit 4.11 + 점진적 리팩토링

> 완벽함보다는 **동작하는 개선**을 목표로, 시간 내에 실질적인 구조 개선을 달성합니다.

이 규칙들을 따라 1일 안에 효과적인 리팩토링을 완료하세요.






















