---
description: 
globs: 
alwaysApply: true
---
# ASSA Chat Server 로그 작성 규칙

## 📋 개요

이 문서는 ASSA Chat Server 프로젝트에서 **실행흐름 파악**과 **디버깅 편의성**을 목적으로 하는 로그 작성 규칙을 정의합니다.

### 목적

- 실시간 채팅 서버의 복잡한 실행 흐름 추적
- 다중 사용자 환경에서의 디버깅 효율성 향상
- WebRTC 시그널링 과정의 상세 추적
- 문제 발생 시 빠른 원인 파악
- 프로덕션 환경에서의 신속한 문제 해결

### 핵심 원칙

1. **컨텍스트가 풍부한 로그**: 누가, 언제, 무엇을, 왜 했는지 명확히 기록
2. **일관된 구조**: 모든 로그가 동일한 패턴과 형식을 따름
3. **적절한 로그 레벨**: 상황에 맞는 정확한 심각도 설정
4. **성능 고려**: 로깅이 애플리케이션 성능에 미치는 영향 최소화
5. **보안 준수**: 민감한 정보 보호 및 마스킹

---

## 🎯 로그 레벨 정의 및 모범사례

> **로그 레벨 선택 가이드**: 각 로그 레벨은 특정 대상과 목적을 가집니다. 적절한 레벨 선택으로 효과적인 로그 관리가 가능합니다.

### TRACE - 가장 상세한 실행 흐름 추적

**대상**: 개발자 (디버깅 시에만 활성화)  
**용도**: 매우 세밀한 실행 흐름, 변수 상태 변화

```java
// 매우 세밀한 실행 흐름 (개발 환경에서만 사용)
log.trace("메서드 진입: processMessage() - messageId={}, userId={}, threadId={}",
          messageId, userId, Thread.currentThread().getId());
log.trace("변수 상태 변경: userId={}, oldStatus={}, newStatus={}, timestamp={}",
          userId, oldStatus, newStatus, System.currentTimeMillis());
log.trace("루프 반복: iteration={}/{}, currentItem={}, processingTime={}ms",
          i, totalItems, currentItem, processingTime);
```

### DEBUG - 상세 실행 흐름 추적

**대상**: 개발자  
**용도**: 메서드 진입/종료, 조건 분기, 상태 확인

```java
// 메서드 진입/종료 (컨텍스트 정보 포함)
log.debug("handleMessage() - START: userId={}, action={}, messageSize={}, timestamp={}",
          userId, action, message.length(), System.currentTimeMillis());
log.debug("handleMessage() - END: result={}, duration={}ms, affectedUsers={}",
          result, duration, affectedUsers);

// 조건문 분기 (결정 근거 포함)
log.debug("메시지 타입 검증: messageType={}, isValid={}, validationRules={}",
          messageType, isValid, validationRules);
log.debug("사용자 권한 확인: userId={}, requiredRole={}, userRole={}, hasPermission={}",
          userId, requiredRole, userRole, hasPermission);

// 반복문 처리 (진행 상황 포함)
log.debug("채팅방 목록 처리: currentIndex={}/{}, roomId={}, participantCount={}",
          i, rooms.size(), room.getId(), room.getParticipantCount());
```

### INFO - 중요 비즈니스 이벤트

**대상**: 개발자, QA, 지원팀  
**용도**: 비즈니스 프로세스, 사용자 행동, 시스템 상태

```java
// 사용자 생명주기 (세션 정보 포함)
log.info("사용자 연결 성공: userId={}, userName={}, socketAddress={}, sessionId={}, userAgent={}",
         userId, userName, socket.getRemoteSocketAddress(), sessionId, userAgent);
log.info("사용자 연결 해제: userId={}, reason={}, sessionDuration={}ms, messagesSent={}, lastActivity={}",
         userId, reason, sessionDuration, messagesSent, lastActivity);

// 채팅방 이벤트 (비즈니스 메트릭 포함)
log.info("채팅방 생성 완료: roomId={}, roomName={}, masterId={}, participantLimit={}, roomType={}",
         roomId, roomName, masterId, participantLimit, roomType);
log.info("메시지 전송 완료: roomId={}, senderId={}, messageType={}, recipientCount={}, deliveryTime={}ms",
         roomId, senderId, messageType, recipientCount, deliveryTime);

// WebRTC 이벤트 (성능 메트릭 포함)
log.info("영상방 생성 완료: videoRoomId={}, masterId={}, maxParticipants={}, codecType={}",
         videoRoomId, masterId, maxParticipants, codecType);
log.info("SDP 교환 완료: fromUserId={}, toUserId={}, sdpType={}, negotiationTime={}ms, bandwidth={}kbps",
         fromUserId, toUserId, sdpType, negotiationTime, bandwidth);
```

### WARN - 예상 가능한 문제 상황

**대상**: 개발자, 운영팀  
**용도**: 잠재적 문제, 성능 이슈, 비정상적 상황

```java
// 비정상적이지만 처리 가능한 상황 (복구 조치 포함)
log.warn("오프라인 사용자에게 메시지 전송 시도: targetUserId={}, messageId={}, queuedForLater=true, queueSize={}",
         targetUserId, messageId, messageQueue.size());
log.warn("존재하지 않는 채팅방 접근 시도: roomId={}, userId={}, redirectedToDefault=true, attemptCount={}",
         roomId, userId, attemptCount);
log.warn("중복 연결 시도 감지: userId={}, existingSocket={}, newSocket={}, actionTaken=closeExisting",
         userId, existingSocket.getRemoteSocketAddress(), newSocket.getRemoteSocketAddress());

// 성능 임계값 초과 (모니터링 필요)
log.warn("성능 임계값 초과: operation={}, duration={}ms, threshold={}ms, currentLoad={}",
         operation, duration, threshold, currentLoad);
log.warn("메모리 사용량 높음: usedMemory={}MB, totalMemory={}MB, usage={}%, threshold={}%",
         usedMemory, totalMemory, usage, threshold);
```

### ERROR - 예외 상황 및 시스템 오류

**대상**: 개발자, 운영팀, 지원팀  
**용도**: 즉시 조사가 필요한 오류, 사용자 영향 있는 문제

```java
// 비즈니스 로직 오류 (복구 시도 정보 포함)
log.error("메시지 전송 실패: userId={}, roomId={}, messageType={}, attemptCount={}, nextRetry={}ms, error={}",
          userId, roomId, messageType, attemptCount, nextRetryTime, e.getMessage(), e);
log.error("사용자 인증 실패: userId={}, authMethod={}, failureReason={}, clientIP={}, attemptCount={}",
          userId, authMethod, failureReason, clientIP, attemptCount, e);

// 시스템 리소스 오류 (시스템 상태 포함)
log.error("데이터베이스 연결 실패: host={}, database={}, connectionPool={}/{}, retryCount={}, error={}",
          dbHost, dbName, activeConnections, maxConnections, retryCount, e.getMessage(), e);
log.error("소켓 통신 오류: userId={}, operation={}, socketState={}, connectionAge={}ms, error={}",
          userId, operation, socket.isClosed() ? "CLOSED" : "OPEN", connectionAge, e.getMessage(), e);
```

### FATAL - 시스템 중단 수준의 심각한 오류

**대상**: 운영팀, 시스템 관리자  
**용도**: 시스템 전체 영향, 즉시 대응 필요

```java
// 시스템 전체에 영향을 미치는 치명적 오류
log.fatal("서버 시작 실패: component={}, reason={}, systemState=SHUTTING_DOWN, error={}",
          component, reason, e.getMessage(), e);
log.fatal("메모리 부족으로 인한 시스템 불안정: availableMemory={}MB, threshold={}MB, activeUsers={}, action=EMERGENCY_SHUTDOWN",
          availableMemory, memoryThreshold, activeUsers);
log.fatal("보안 침해 감지: attackType={}, sourceIP={}, targetResource={}, attemptCount={}, action=BLOCK_IP",
          attackType, sourceIP, targetResource, attemptCount);
```

### 로그 레벨 선택 기준

| 레벨  | 프로덕션 사용 | 성능 영향 | 대상 독자          | 즉시 대응 필요 |
| ----- | ------------- | --------- | ------------------ | -------------- |
| TRACE | ❌            | 높음      | 개발자             | ❌             |
| DEBUG | 제한적        | 중간      | 개발자             | ❌             |
| INFO  | ✅            | 낮음      | 개발자, QA, 지원팀 | ❌             |
| WARN  | ✅            | 낮음      | 개발자, 운영팀     | 모니터링       |
| ERROR | ✅            | 낮음      | 모든 팀            | ✅             |
| FATAL | ✅            | 낮음      | 운영팀, 관리자     | 즉시           |

---

## 🔍 실행흐름 추적을 위한 로그 패턴

### 1. 메서드 진입/종료 패턴

```java
public void sendMessage(String message, int roomId) {
    log.debug("sendMessage() - START: message={}, roomId={}, userId={}",
              message, roomId, this.userId);

    try {
        // 비즈니스 로직
        log.debug("메시지 유효성 검사 완료");
        log.debug("채팅방 존재 확인 완료: roomId={}", roomId);
        log.debug("메시지 DB 저장 완료: messageId={}", messageId);

    } catch (Exception e) {
        log.error("sendMessage() - ERROR: {}", e.getMessage(), e);
        throw e;
    } finally {
        log.debug("sendMessage() - END");
    }
}
```

### 2. 조건 분기 추적 패턴

```java
public void processCommand(String jsonMessage) {
    log.debug("processCommand() - START: jsonMessage={}", jsonMessage);

    Action action = parseAction(jsonMessage);
    log.debug("명령 파싱 완료: action={}", action);

    switch (action) {
        case SEND_MESSAGE:
            log.debug("메시지 전송 명령 처리 시작");
            handleSendMessage(jsonMessage);
            break;
        case CREATE_ROOM:
            log.debug("채팅방 생성 명령 처리 시작");
            handleCreateRoom(jsonMessage);
            break;
        default:
            log.warn("알 수 없는 명령: action={}", action);
    }

    log.debug("processCommand() - END");
}
```

### 3. 상태 변화 추적 패턴

```java
public void updateConnectionStatus(boolean connected) {
    log.debug("연결 상태 변경: userId={}, 이전상태={}, 새상태={}",
              userId, this.isConnected, connected);

    this.isConnected = connected;

    if (connected) {
        log.info("사용자 온라인 상태로 변경: userId={}", userId);
        processOfflineMessages();
    } else {
        log.info("사용자 오프라인 상태로 변경: userId={}", userId);
        cleanupResources();
    }
}
```

---

## 🐛 디버깅을 위한 로그 패턴

### 1. 데이터 상태 로깅

```java
// 컬렉션 상태
log.debug("현재 연결된 사용자 수: {}", connectedUsers.size());
log.debug("활성 채팅방 수: {}", activeChatRooms.size());
log.debug("대기 중인 메시지 수: userId={}, queueSize={}", userId, messageQueue.size());

// 객체 상태
log.debug("사용자 정보: userId={}, userName={}, isConnected={}",
          userId, userName, isConnected);
log.debug("채팅방 정보: roomId={}, participantCount={}, roomType={}",
          roomId, participants.size(), roomType);
```

### 2. 타이밍 정보 로깅

```java
public void handleMessage(String message) {
    long startTime = System.currentTimeMillis();
    log.debug("메시지 처리 시작: timestamp={}", startTime);

    try {
        // 처리 로직

    } finally {
        long endTime = System.currentTimeMillis();
        long duration = endTime - startTime;
        log.debug("메시지 처리 완료: duration={}ms", duration);

        if (duration > 1000) {
            log.warn("메시지 처리 시간 초과: duration={}ms", duration);
        }
    }
}
```

### 3. 네트워크 통신 로깅

```java
// 소켓 통신
log.debug("소켓 메시지 전송 시도: targetUserId={}, messageLength={}",
          targetUserId, message.length());
log.debug("소켓 메시지 전송 완료: targetUserId={}", targetUserId);

// WebRTC 시그널링
log.debug("SDP 전송: fromUserId={}, toUserId={}, sdpType={}, sdpLength={}",
          fromUserId, toUserId, sdpType, sdp.length());
log.debug("ICE Candidate 전송: fromUserId={}, toUserId={}, candidate={}",
          fromUserId, toUserId, candidate);
```

---

## 📊 다중 사용자 환경 로깅

### 1. 사용자 식별 정보 포함

```java
// 모든 로그에 사용자 식별 정보 포함
log.debug("[User:{}] 메시지 처리 시작: action={}", userId, action);
log.info("[User:{}] 채팅방 입장: roomId={}", userId, roomId);
log.error("[User:{}] 처리 오류: {}", userId, e.getMessage(), e);
```

### 2. 세션/스레드 정보 포함

```java
// 스레드 정보로 동시 처리 추적
log.debug("[Thread:{}][User:{}] 명령 처리: action={}",
          Thread.currentThread().getName(), userId, action);
```

### 3. 상호작용 로깅

```java
// 사용자 간 상호작용
log.info("메시지 전송: 발신자={}, 수신자={}, 채팅방={}",
         senderId, receiverId, roomId);
log.info("영상통화 초대: 발신자={}, 수신자={}, 영상방={}",
         callerId, calleeId, videoRoomId);
```

---

## 🔧 WebRTC 시그널링 전용 로깅

### 1. 시그널링 과정 추적

```java
// SDP 교환 과정
log.info("SDP Offer 생성: callerId={}, calleeId={}, videoRoomId={}",
         callerId, calleeId, videoRoomId);
log.info("SDP Answer 수신: calleeId={}, callerId={}, videoRoomId={}",
         calleeId, callerId, videoRoomId);

// ICE 후보 교환
log.debug("ICE Candidate 수집: userId={}, candidateCount={}",
          userId, candidateCount);
log.debug("ICE Candidate 전송: fromUserId={}, toUserId={}, candidate={}",
          fromUserId, toUserId, candidate);
```

### 2. 미디어 상태 추적

```java
// 미디어 상태 변경
log.info("카메라 상태 변경: userId={}, videoRoomId={}, enabled={}",
         userId, videoRoomId, cameraEnabled);
log.info("마이크 상태 변경: userId={}, videoRoomId={}, enabled={}",
         userId, videoRoomId, micEnabled);
```

---

## 📝 로그 메시지 작성 규칙 및 모범사례

### 1. 의미 있는 메시지 작성

#### ❌ 나쁜 예시

```java
log.info("처리 중");
log.error("오류 발생");
log.debug("메서드 시작");
```

#### ✅ 좋은 예시

```java
log.info("사용자 메시지 처리 중: userId={}, messageType={}, roomId={}", userId, messageType, roomId);
log.error("데이터베이스 연결 오류: host={}, timeout={}ms, retryCount={}", dbHost, timeout, retryCount);
log.debug("메시지 검증 시작: messageId={}, senderId={}, contentLength={}", messageId, senderId, content.length());
```

### 2. 구조화된 메시지 형식

#### 기본 형식 패턴

```java
// 성공 케이스: [동작] + [결과] + [핵심 정보] + [메트릭]
log.info("메시지 전송 완료: roomId={}, messageId={}, recipientCount={}, deliveryTime={}ms",
         roomId, messageId, recipientCount, deliveryTime);

// 실패 케이스: [동작] + [실패 원인] + [컨텍스트] + [복구 조치]
log.error("채팅방 생성 실패: 중복된 방 이름, roomName={}, masterId={}, suggestedName={}",
          roomName, masterId, suggestedName);

// 상태 변화: [이전 상태] → [새 상태] + [변화 원인] + [영향]
log.info("사용자 상태 변경: userId={}, {} → {}, reason={}, affectedRooms={}",
         userId, oldStatus, newStatus, reason, affectedRooms.size());
```

### 3. 컨텍스트 정보 포함

#### 필수 컨텍스트 요소

```java
// WHO: 누가 (사용자, 시스템 컴포넌트)
// WHAT: 무엇을 (수행한 작업, 발생한 이벤트)
// WHEN: 언제 (타임스탬프는 자동, 필요시 비즈니스 시간)
// WHERE: 어디서 (메서드, 클래스, 서버)
// WHY: 왜 (원인, 트리거)
// HOW: 어떻게 (방법, 결과)

log.info("사용자 채팅방 입장: userId={}, userName={}, roomId={}, roomName={}, entryMethod={}, participantCount={}",
         userId, userName, roomId, roomName, entryMethod, participantCount);
```

### 4. 변수 명명 및 값 표현

#### 명확한 변수명 사용

```java
// ❌ 모호한 명명
log.debug("처리: id={}, cnt={}, res={}", id, cnt, res);

// ✅ 명확한 명명
log.debug("메시지 처리 완료: messageId={}, recipientCount={}, deliveryResult={}",
          messageId, recipientCount, deliveryResult);
```

#### 단위 및 형식 명시

```java
// 시간 단위 명시
log.info("작업 완료: duration={}ms, timeout={}s", duration, timeout);

// 크기 단위 명시
log.warn("메모리 사용량 높음: usedMemory={}MB, maxMemory={}MB", usedMemory, maxMemory);

// 상태 값 명시
log.debug("연결 상태: isConnected={}, socketState={}, lastHeartbeat={}ms ago",
          isConnected, socket.isClosed() ? "CLOSED" : "OPEN", lastHeartbeat);
```

### 5. 예외 처리 로깅

#### 예외 정보 완전 기록

```java
// ❌ 불충분한 예외 로깅
log.error("오류 발생", e);

// ✅ 완전한 예외 로깅
log.error("메시지 전송 실패: userId={}, roomId={}, messageType={}, attemptCount={}, error={}",
          userId, roomId, messageType, attemptCount, e.getMessage(), e);
```

#### 예외 처리 패턴

```java
public void processMessage(String message) {
    String messageId = generateMessageId();
    try {
        log.debug("메시지 처리 시작: messageId={}, size={}", messageId, message.length());

        // 비즈니스 로직

        log.info("메시지 처리 완료: messageId={}", messageId);
    } catch (ValidationException e) {
        log.warn("메시지 검증 실패: messageId={}, validationError={}, message={}",
                 messageId, e.getValidationError(), message, e);
    } catch (Exception e) {
        log.error("메시지 처리 중 예상치 못한 오류: messageId={}, error={}",
                  messageId, e.getMessage(), e);
        throw e;
    }
}
```

### 6. 민감 정보 보호

#### 마스킹 전략

```java
// 비밀번호 완전 마스킹
log.debug("사용자 로그인 시도: userId={}, password={}", userId, "****");

// 이메일 부분 마스킹
log.info("사용자 등록: email={}, phone={}",
         maskEmail(email), maskPhone(phone));

// 토큰 부분 표시
log.debug("API 호출: endpoint={}, token={}...{}",
          endpoint, token.substring(0, 4), token.substring(token.length() - 4));

// 마스킹 유틸리티 메서드
private String maskEmail(String email) {
    if (email == null || !email.contains("@")) return "****";
    String[] parts = email.split("@");
    return parts[0].substring(0, 2) + "****@" + parts[1];
}

private String maskPhone(String phone) {
    if (phone == null || phone.length() < 4) return "****";
    return phone.substring(0, 3) + "****" + phone.substring(phone.length() - 2);
}
```

### 7. 성능 고려사항

#### 조건부 로깅

```java
// ❌ 성능에 영향을 주는 로깅
log.debug("복잡한 객체 정보: " + expensiveToString(complexObject));

// ✅ 조건부 로깅
if (log.isDebugEnabled()) {
    log.debug("복잡한 객체 정보: {}", expensiveToString(complexObject));
}

// ✅ 람다를 이용한 지연 평가 (Log4j2)
log.debug("복잡한 객체 정보: {}", () -> expensiveToString(complexObject));
```

#### 문자열 연결 피하기

```java
// ❌ 문자열 연결
log.info("사용자 " + userId + "가 방 " + roomId + "에 입장했습니다");

// ✅ 파라미터화된 메시지
log.info("사용자 {}가 방 {}에 입장했습니다", userId, roomId);
```

### 8. 일관성 있는 메시지 패턴

#### 표준 메시지 템플릿

```java
// 시작/종료 패턴
log.debug("{}() - START: {}", methodName, parameters);
log.debug("{}() - END: result={}, duration={}ms", methodName, result, duration);

// 상태 변경 패턴
log.info("{} 상태 변경: {} → {}, reason={}", entityType, oldState, newState, reason);

// 리소스 사용 패턴
log.warn("{} 리소스 임계값 초과: current={}, threshold={}, usage={}%",
         resourceType, current, threshold, usage);

// 외부 시스템 호출 패턴
log.debug("외부 API 호출: endpoint={}, method={}, requestId={}", endpoint, method, requestId);
log.info("외부 API 응답: endpoint={}, status={}, duration={}ms, requestId={}",
         endpoint, status, duration, requestId);
```

### 9. 로그 메시지 검증 체크리스트

#### 메시지 작성 전 확인사항

- [ ] **명확성**: 메시지만 보고도 상황을 이해할 수 있는가?
- [ ] **컨텍스트**: 누가, 무엇을, 언제, 어디서, 왜, 어떻게가 포함되었는가?
- [ ] **유용성**: 디버깅이나 모니터링에 실제로 도움이 되는가?
- [ ] **일관성**: 프로젝트의 다른 로그와 형식이 일치하는가?
- [ ] **보안**: 민감한 정보가 노출되지 않는가?
- [ ] **성능**: 로깅으로 인한 성능 저하가 없는가?
- [ ] **적절성**: 로그 레벨이 메시지의 중요도와 일치하는가?

---

## 🎛️ 로그 설정 (log4j2.xml)

### 개발 환경 설정

```xml
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="WARN">
    <Appenders>
        <!-- 콘솔 출력 -->
        <Console name="Console" target="SYSTEM_OUT">
            <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
        </Console>

        <!-- 파일 출력 -->
        <File name="FileAppender" fileName="logs/assa-chat-server.log">
            <PatternLayout pattern="%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
        </File>
    </Appenders>

    <Loggers>
        <!-- 패키지별 로그 레벨 설정 -->
        <Logger name="com.teamnova.user" level="DEBUG" additivity="false">
            <AppenderRef ref="Console"/>
            <AppenderRef ref="FileAppender"/>
        </Logger>

        <Logger name="com.teamnova.chat" level="DEBUG" additivity="false">
            <AppenderRef ref="Console"/>
            <AppenderRef ref="FileAppender"/>
        </Logger>

        <Logger name="com.teamnova.webrtc" level="DEBUG" additivity="false">
            <AppenderRef ref="Console"/>
            <AppenderRef ref="FileAppender"/>
        </Logger>

        <Root level="INFO">
            <AppenderRef ref="Console"/>
            <AppenderRef ref="FileAppender"/>
        </Root>
    </Loggers>
</Configuration>
```

---

## 🚀 실제 적용 예시

### User 클래스 로깅 예시 (개선된 버전)

```java
public class User extends Thread {
    private static final Logger log = LogManager.getLogger(User.class);
    private final String sessionId = UUID.randomUUID().toString().substring(0, 8);
    private long connectionStartTime;
    private int messageCount = 0;

    @Override
    public void run() {
        connectionStartTime = System.currentTimeMillis();

        log.info("사용자 세션 시작: userId={}, sessionId={}, socketAddress={}, threadId={}, timestamp={}",
                 userId, sessionId, socket.getRemoteSocketAddress(),
                 Thread.currentThread().getId(), connectionStartTime);

        try {
            while (isConnected && !socket.isClosed()) {
                log.trace("메시지 대기 상태: userId={}, sessionId={}, socketState={}, isConnected={}",
                         userId, sessionId, socket.isClosed() ? "CLOSED" : "OPEN", isConnected);

                String message = bufferedReader.readLine();
                if (message != null) {
                    messageCount++;
                    log.debug("메시지 수신: userId={}, sessionId={}, messageCount={}, messageSize={}bytes, timestamp={}",
                             userId, sessionId, messageCount, message.length(), System.currentTimeMillis());

                    long processingStart = System.currentTimeMillis();
                    processMessage(message);
                    long processingTime = System.currentTimeMillis() - processingStart;

                    log.debug("메시지 처리 완료: userId={}, sessionId={}, messageCount={}, processingTime={}ms",
                             userId, sessionId, messageCount, processingTime);
                } else {
                    log.warn("연결 종료 신호 감지: userId={}, sessionId={}, messageCount={}, sessionDuration={}ms",
                            userId, sessionId, messageCount, System.currentTimeMillis() - connectionStartTime);
                    break;
                }
            }
        } catch (IOException e) {
            log.error("소켓 통신 오류: userId={}, sessionId={}, messageCount={}, sessionDuration={}ms, error={}",
                     userId, sessionId, messageCount,
                     System.currentTimeMillis() - connectionStartTime, e.getMessage(), e);
        } finally {
            long sessionDuration = System.currentTimeMillis() - connectionStartTime;
            log.info("사용자 세션 종료: userId={}, sessionId={}, totalMessages={}, sessionDuration={}ms, avgProcessingTime={}ms",
                     userId, sessionId, messageCount, sessionDuration,
                     messageCount > 0 ? sessionDuration / messageCount : 0);
            cleanup();
        }
    }

    private void processMessage(String message) {
        String requestId = UUID.randomUUID().toString().substring(0, 8);

        log.debug("메시지 처리 시작: userId={}, sessionId={}, requestId={}, messageSize={}bytes",
                  userId, sessionId, requestId, message.length());

        try {
            // JSON 파싱
            JsonObject jsonObject = JsonParser.parseString(message).getAsJsonObject();
            String actionStr = jsonObject.get("action").getAsString();
            Action action = Action.valueOf(actionStr);

            log.debug("명령 파싱 성공: userId={}, sessionId={}, requestId={}, action={}, hasRequester={}",
                     userId, sessionId, requestId, action, jsonObject.has("requesterId"));

            // 명령 실행
            long commandStart = System.currentTimeMillis();
            BaseCommand command = action.createCommand();
            command.execute(this, jsonObject);
            long commandDuration = System.currentTimeMillis() - commandStart;

            log.info("명령 실행 완료: userId={}, sessionId={}, requestId={}, action={}, duration={}ms",
                    userId, sessionId, requestId, action, commandDuration);

        } catch (JsonSyntaxException e) {
            log.error("JSON 파싱 실패: userId={}, sessionId={}, requestId={}, messagePreview={}, error={}",
                     userId, sessionId, requestId,
                     message.length() > 100 ? message.substring(0, 100) + "..." : message,
                     e.getMessage(), e);
        } catch (IllegalArgumentException e) {
            log.error("알 수 없는 액션: userId={}, sessionId={}, requestId={}, action={}, error={}",
                     userId, sessionId, requestId,
                     jsonObject != null ? jsonObject.get("action") : "null", e.getMessage());
        } catch (Exception e) {
            log.error("메시지 처리 중 예상치 못한 오류: userId={}, sessionId={}, requestId={}, error={}",
                     userId, sessionId, requestId, e.getMessage(), e);
        }
    }
}
```

### MessageHandler 로깅 예시 (개선된 버전)

```java
public class MessageHandler {
    private static final Logger log = LogManager.getLogger(MessageHandler.class);

    public void sendMessage(User sender, String content, int roomId, String messageType) {
        String operationId = UUID.randomUUID().toString().substring(0, 8);
        long startTime = System.currentTimeMillis();

        log.debug("메시지 전송 시작: operationId={}, senderId={}, roomId={}, messageType={}, contentLength={}bytes",
                  operationId, sender.getUserId(), roomId, messageType, content.length());

        try {
            // 1. 채팅방 존재 확인
            ChatRoom chatRoom = ChatServer.getChatRoom(roomId);
            if (chatRoom == null) {
                log.warn("채팅방 접근 실패: operationId={}, senderId={}, roomId={}, reason=ROOM_NOT_FOUND",
                        operationId, sender.getUserId(), roomId);
                sendErrorResponse(sender, "ROOM_NOT_FOUND", operationId);
                return;
            }

            log.debug("채팅방 검증 완료: operationId={}, roomId={}, roomName={}, participantCount={}, roomType={}",
                      operationId, roomId, chatRoom.getRoomName(),
                      chatRoom.getParticipants().size(), chatRoom.getRoomType());

            // 2. 권한 확인
            if (!chatRoom.hasParticipant(sender.getUserId())) {
                log.warn("권한 없는 메시지 전송 시도: operationId={}, senderId={}, roomId={}, reason=NOT_PARTICIPANT",
                        operationId, sender.getUserId(), roomId);
                sendErrorResponse(sender, "ACCESS_DENIED", operationId);
                return;
            }

            // 3. 메시지 DB 저장
            long dbStartTime = System.currentTimeMillis();
            int messageId = saveMessageToDatabase(sender.getUserId(), roomId, content, messageType);
            long dbDuration = System.currentTimeMillis() - dbStartTime;

            log.debug("메시지 DB 저장 완료: operationId={}, messageId={}, dbDuration={}ms",
                      operationId, messageId, dbDuration);

            // 4. 참가자들에게 메시지 전송
            List<User> participants = chatRoom.getParticipants();
            List<User> onlineParticipants = new ArrayList<>();
            List<Integer> offlineParticipants = new ArrayList<>();
            int sentCount = 0;
            int failedCount = 0;

            for (User participant : participants) {
                if (participant.getUserId() != sender.getUserId()) {
                    try {
                        if (participant.isConnected()) {
                            participant.sendMessage(createMessageJson(messageId, content, messageType, sender));
                            onlineParticipants.add(participant);
                            sentCount++;

                            log.trace("개별 메시지 전송 성공: operationId={}, targetUserId={}, messageId={}",
                                     operationId, participant.getUserId(), messageId);
                        } else {
                            offlineParticipants.add(participant.getUserId());
                            log.debug("오프라인 사용자 감지: operationId={}, targetUserId={}, messageId={}, action=QUEUED",
                                     operationId, participant.getUserId(), messageId);
                        }
                    } catch (Exception e) {
                        failedCount++;
                        log.error("개별 메시지 전송 실패: operationId={}, targetUserId={}, messageId={}, error={}",
                                 operationId, participant.getUserId(), messageId, e.getMessage(), e);
                    }
                }
            }

            long totalDuration = System.currentTimeMillis() - startTime;

            log.info("메시지 전송 완료: operationId={}, senderId={}, roomId={}, messageId={}, " +
                    "totalParticipants={}, onlineCount={}, offlineCount={}, sentCount={}, failedCount={}, " +
                    "totalDuration={}ms, dbDuration={}ms, deliveryRate={}%",
                    operationId, sender.getUserId(), roomId, messageId,
                    participants.size() - 1, onlineParticipants.size(), offlineParticipants.size(),
                    sentCount, failedCount, totalDuration, dbDuration,
                    participants.size() > 1 ? (sentCount * 100 / (participants.size() - 1)) : 100);

            // 5. 전송 상태 업데이트
            updateMessageDeliveryStatus(messageId, sentCount, failedCount, operationId);

        } catch (DatabaseException e) {
            log.error("데이터베이스 오류: operationId={}, senderId={}, roomId={}, error={}, sqlState={}",
                     operationId, sender.getUserId(), roomId, e.getMessage(), e.getSQLState(), e);
            sendErrorResponse(sender, "DATABASE_ERROR", operationId);
        } catch (Exception e) {
            long totalDuration = System.currentTimeMillis() - startTime;
            log.error("메시지 전송 중 예상치 못한 오류: operationId={}, senderId={}, roomId={}, " +
                     "duration={}ms, error={}",
                     operationId, sender.getUserId(), roomId, totalDuration, e.getMessage(), e);
            sendErrorResponse(sender, "INTERNAL_ERROR", operationId);
        }
    }

    private void sendErrorResponse(User user, String errorCode, String operationId) {
        try {
            JsonObject errorResponse = new JsonObject();
            errorResponse.addProperty("action", "ERROR");
            errorResponse.addProperty("errorCode", errorCode);
            errorResponse.addProperty("operationId", operationId);
            errorResponse.addProperty("timestamp", System.currentTimeMillis());

            user.sendMessage(errorResponse.toString());

            log.debug("에러 응답 전송: operationId={}, userId={}, errorCode={}",
                     operationId, user.getUserId(), errorCode);
        } catch (Exception e) {
            log.error("에러 응답 전송 실패: operationId={}, userId={}, errorCode={}, error={}",
                     operationId, user.getUserId(), errorCode, e.getMessage());
        }
    }
}
```

### WebRTC 시그널링 로깅 예시

```java
public class WebRTCSignalingHandler {
    private static final Logger log = LogManager.getLogger(WebRTCSignalingHandler.class);

    public void handleSDP(User fromUser, User toUser, String sdpType, String sdp) {
        String signalId = UUID.randomUUID().toString().substring(0, 8);
        long startTime = System.currentTimeMillis();

        log.info("SDP 시그널링 시작: signalId={}, fromUserId={}, toUserId={}, sdpType={}, sdpSize={}bytes",
                signalId, fromUser.getUserId(), toUser.getUserId(), sdpType, sdp.length());

        try {
            // SDP 유효성 검증
            if (!isValidSDP(sdp, sdpType)) {
                log.warn("SDP 검증 실패: signalId={}, fromUserId={}, toUserId={}, sdpType={}, reason=INVALID_FORMAT",
                        signalId, fromUser.getUserId(), toUser.getUserId(), sdpType);
                return;
            }

            // 대상 사용자 연결 상태 확인
            if (!toUser.isConnected()) {
                log.warn("SDP 전송 실패: signalId={}, fromUserId={}, toUserId={}, reason=TARGET_OFFLINE",
                        signalId, fromUser.getUserId(), toUser.getUserId());
                return;
            }

            // SDP 메시지 생성 및 전송
            JsonObject sdpMessage = createSDPMessage(fromUser.getUserId(), sdpType, sdp, signalId);
            toUser.sendMessage(sdpMessage.toString());

            long duration = System.currentTimeMillis() - startTime;

            log.info("SDP 시그널링 완료: signalId={}, fromUserId={}, toUserId={}, sdpType={}, " +
                    "duration={}ms, messageSize={}bytes",
                    signalId, fromUser.getUserId(), toUser.getUserId(), sdpType,
                    duration, sdpMessage.toString().length());

            // 통계 업데이트
            updateSignalingStats(sdpType, duration);

        } catch (Exception e) {
            long duration = System.currentTimeMillis() - startTime;
            log.error("SDP 시그널링 오류: signalId={}, fromUserId={}, toUserId={}, sdpType={}, " +
                     "duration={}ms, error={}",
                     signalId, fromUser.getUserId(), toUser.getUserId(), sdpType,
                     duration, e.getMessage(), e);
        }
    }
}
```

---

## 📋 로그 분석 및 모니터링

### 1. 실시간 모니터링 명령어

#### 시스템 상태 모니터링

```bash
# 실시간 로그 모니터링
tail -f logs/assa-chat-server.log

# 에러 로그만 실시간 모니터링
tail -f logs/assa-chat-server.log | grep "ERROR\|FATAL"

# 특정 레벨 이상 로그 모니터링
tail -f logs/assa-chat-server.log | grep -E "WARN|ERROR|FATAL"

# 성능 관련 로그 모니터링
tail -f logs/assa-chat-server.log | grep -E "duration=|processingTime=|timeout"
```

#### 사용자 활동 모니터링

```bash
# 사용자 연결/해제 현황
grep -E "사용자 세션 시작|사용자 세션 종료" assa-chat-server.log | tail -20

# 현재 활성 사용자 수 (최근 1시간)
grep "사용자 세션 시작" assa-chat-server.log | grep "$(date '+%Y-%m-%d %H')" | wc -l

# 메시지 전송 통계 (최근 1시간)
grep "메시지 전송 완료" assa-chat-server.log | grep "$(date '+%Y-%m-%d %H')" | wc -l

# 평균 세션 시간 계산
grep "sessionDuration=" assa-chat-server.log | tail -100 | \
  sed 's/.*sessionDuration=\([0-9]*\)ms.*/\1/' | \
  awk '{sum+=$1; count++} END {print "평균 세션 시간:", sum/count/1000, "초"}'
```

### 2. 디버깅 시나리오별 로그 검색

#### 특정 사용자 추적

```bash
# 특정 사용자의 전체 활동 추적
grep "userId=123" assa-chat-server.log | head -50

# 특정 사용자의 세션 정보
grep -E "userId=123.*sessionId=" assa-chat-server.log

# 특정 사용자의 에러 로그만
grep "userId=123" assa-chat-server.log | grep "ERROR"

# 특정 세션의 모든 활동 추적
grep "sessionId=abc12345" assa-chat-server.log
```

#### 채팅방 관련 디버깅

```bash
# 특정 채팅방의 모든 활동
grep "roomId=456" assa-chat-server.log

# 채팅방 생성/삭제 이벤트
grep -E "채팅방 생성|채팅방 삭제" assa-chat-server.log

# 메시지 전송 실패 분석
grep "메시지 전송 실패\|개별 메시지 전송 실패" assa-chat-server.log | tail -20

# 특정 채팅방의 성능 메트릭
grep "roomId=456" assa-chat-server.log | grep -E "duration=|deliveryTime="
```

#### WebRTC 시그널링 디버깅

```bash
# SDP 교환 과정 추적
grep -E "SDP 시그널링|signalId=" assa-chat-server.log

# ICE 후보 교환 추적
grep "ICE" assa-chat-server.log

# WebRTC 연결 실패 분석
grep -E "SDP.*실패|ICE.*실패|WebRTC.*오류" assa-chat-server.log

# 영상방 참가자 변화 추적
grep -E "영상방.*참가|영상방.*퇴장" assa-chat-server.log
```

### 3. 성능 분석 쿼리

#### 응답 시간 분석

```bash
# 평균 메시지 처리 시간
grep "processingTime=" assa-chat-server.log | tail -1000 | \
  sed 's/.*processingTime=\([0-9]*\)ms.*/\1/' | \
  awk '{sum+=$1; count++} END {print "평균 처리 시간:", sum/count, "ms"}'

# 느린 요청 찾기 (100ms 이상)
grep "duration=" assa-chat-server.log | \
  sed 's/.*duration=\([0-9]*\)ms.*/\1/' | \
  awk '$1 > 100 {print}' | wc -l

# 데이터베이스 쿼리 성능
grep "dbDuration=" assa-chat-server.log | tail -100 | \
  sed 's/.*dbDuration=\([0-9]*\)ms.*/\1/' | \
  awk '{sum+=$1; count++} END {print "평균 DB 시간:", sum/count, "ms"}'
```

#### 에러 패턴 분석

```bash
# 에러 발생 빈도 (시간대별)
grep "ERROR" assa-chat-server.log | \
  cut -d' ' -f1-2 | sort | uniq -c | tail -24

# 가장 빈번한 에러 메시지
grep "ERROR" assa-chat-server.log | \
  sed 's/.*ERROR.*- //' | cut -d':' -f1 | sort | uniq -c | sort -nr | head -10

# 특정 에러의 발생 추이
grep "JSON 파싱 실패" assa-chat-server.log | \
  cut -d' ' -f1 | sort | uniq -c

# 연결 관련 에러 분석
grep -E "소켓 통신 오류|연결.*실패" assa-chat-server.log | tail -20
```

### 4. 비즈니스 메트릭 추출

#### 사용자 활동 통계

```bash
# 일별 활성 사용자 수
grep "사용자 세션 시작" assa-chat-server.log | \
  cut -d' ' -f1 | sort | uniq -c

# 시간대별 접속 패턴
grep "사용자 세션 시작" assa-chat-server.log | \
  cut -d' ' -f2 | cut -d':' -f1 | sort | uniq -c

# 메시지 전송 성공률
total_attempts=$(grep "메시지 전송 시작" assa-chat-server.log | wc -l)
successful=$(grep "메시지 전송 완료" assa-chat-server.log | wc -l)
echo "메시지 전송 성공률: $(echo "scale=2; $successful * 100 / $total_attempts" | bc)%"

# 평균 채팅방 참가자 수
grep "participantCount=" assa-chat-server.log | \
  sed 's/.*participantCount=\([0-9]*\).*/\1/' | \
  awk '{sum+=$1; count++} END {print "평균 참가자 수:", sum/count}'
```

#### WebRTC 통계

```bash
# SDP 교환 성공률
sdp_attempts=$(grep "SDP 시그널링 시작" assa-chat-server.log | wc -l)
sdp_success=$(grep "SDP 시그널링 완료" assa-chat-server.log | wc -l)
echo "SDP 교환 성공률: $(echo "scale=2; $sdp_success * 100 / $sdp_attempts" | bc)%"

# 영상통화 세션 통계
grep -E "영상방 생성|영상방.*종료" assa-chat-server.log | tail -20

# 평균 시그널링 시간
grep "SDP 시그널링 완료" assa-chat-server.log | \
  sed 's/.*duration=\([0-9]*\)ms.*/\1/' | \
  awk '{sum+=$1; count++} END {print "평균 시그널링 시간:", sum/count, "ms"}'
```

### 5. 로그 분석 스크립트 예시

#### 종합 상태 리포트 스크립트

```bash
#!/bin/bash
# log_report.sh - ASSA Chat Server 로그 분석 리포트

LOG_FILE="logs/assa-chat-server.log"
TODAY=$(date '+%Y-%m-%d')

echo "=== ASSA Chat Server 일일 리포트 ($TODAY) ==="
echo

# 1. 기본 통계
echo "📊 기본 통계"
echo "- 총 로그 라인 수: $(wc -l < $LOG_FILE)"
echo "- 오늘 로그 라인 수: $(grep "$TODAY" $LOG_FILE | wc -l)"
echo "- 에러 발생 수: $(grep "ERROR" $LOG_FILE | grep "$TODAY" | wc -l)"
echo "- 경고 발생 수: $(grep "WARN" $LOG_FILE | grep "$TODAY" | wc -l)"
echo

# 2. 사용자 활동
echo "👥 사용자 활동"
active_users=$(grep "사용자 세션 시작" $LOG_FILE | grep "$TODAY" | wc -l)
echo "- 오늘 활성 사용자: $active_users 명"
echo "- 현재 연결된 사용자: $(grep "사용자 세션 시작" $LOG_FILE | grep "$TODAY" | wc -l) 명"
echo

# 3. 메시지 통계
echo "💬 메시지 통계"
messages_sent=$(grep "메시지 전송 완료" $LOG_FILE | grep "$TODAY" | wc -l)
echo "- 오늘 전송된 메시지: $messages_sent 개"
if [ $messages_sent -gt 0 ]; then
    avg_delivery_rate=$(grep "deliveryRate=" $LOG_FILE | grep "$TODAY" | \
        sed 's/.*deliveryRate=\([0-9]*\)%.*/\1/' | \
        awk '{sum+=$1; count++} END {print sum/count}')
    echo "- 평균 전송 성공률: ${avg_delivery_rate}%"
fi
echo

# 4. 성능 메트릭
echo "⚡ 성능 메트릭"
if grep "processingTime=" $LOG_FILE | grep "$TODAY" | head -1 > /dev/null; then
    avg_processing=$(grep "processingTime=" $LOG_FILE | grep "$TODAY" | \
        sed 's/.*processingTime=\([0-9]*\)ms.*/\1/' | \
        awk '{sum+=$1; count++} END {print sum/count}')
    echo "- 평균 메시지 처리 시간: ${avg_processing}ms"
fi

if grep "dbDuration=" $LOG_FILE | grep "$TODAY" | head -1 > /dev/null; then
    avg_db=$(grep "dbDuration=" $LOG_FILE | grep "$TODAY" | \
        sed 's/.*dbDuration=\([0-9]*\)ms.*/\1/' | \
        awk '{sum+=$1; count++} END {print sum/count}')
    echo "- 평균 DB 응답 시간: ${avg_db}ms"
fi
echo

# 5. 최근 에러
echo "🚨 최근 에러 (최근 10개)"
grep "ERROR" $LOG_FILE | tail -10 | while read line; do
    echo "  - $line"
done
echo

echo "리포트 생성 완료: $(date)"
```

### 6. 알림 및 모니터링 설정

#### 실시간 알림 스크립트

```bash
#!/bin/bash
# alert_monitor.sh - 실시간 에러 모니터링

LOG_FILE="logs/assa-chat-server.log"

# 에러 발생 시 알림
tail -f $LOG_FILE | while read line; do
    if echo "$line" | grep -q "ERROR\|FATAL"; then
        echo "[ALERT] $(date): $line"
        # 여기에 Slack, 이메일 등 알림 로직 추가
    fi

    # 성능 임계값 초과 시 알림
    if echo "$line" | grep -q "duration=" && \
       echo "$line" | sed 's/.*duration=\([0-9]*\)ms.*/\1/' | \
       awk '$1 > 5000 {exit 0} {exit 1}'; then
        echo "[PERFORMANCE ALERT] 응답 시간 5초 초과: $line"
    fi
done
```

---

## ✅ 로그 작성 체크리스트

### 📝 메서드 작성 시

#### 필수 로그

- [ ] **메서드 진입**: 주요 매개변수와 함께 DEBUG 레벨로 기록
- [ ] **메서드 종료**: 결과값과 처리 시간 포함하여 DEBUG 레벨로 기록
- [ ] **예외 처리**: 모든 catch 블록에 ERROR 레벨 로그 추가
- [ ] **중요 분기점**: 조건문의 주요 분기에 DEBUG 로그 추가

#### 권장 로그

- [ ] **성능 메트릭**: 처리 시간이 중요한 메서드는 duration 측정
- [ ] **상태 변화**: 객체 상태가 변경되는 시점에 INFO 로그
- [ ] **외부 호출**: 데이터베이스, API 호출 전후 로그
- [ ] **검증 결과**: 입력값 검증 결과 로그

### 🔧 비즈니스 로직 작성 시

#### 사용자 관련 로직

- [ ] **연결/해제**: 사용자 세션 시작/종료 시 INFO 로그
- [ ] **인증/권한**: 인증 시도 및 권한 확인 결과 로그
- [ ] **상태 변경**: 사용자 상태 변화 시 INFO 로그
- [ ] **에러 처리**: 사용자 관련 에러 시 userId 포함하여 로그

#### 메시지 처리 로직

- [ ] **메시지 수신**: 메시지 크기, 타입과 함께 DEBUG 로그
- [ ] **메시지 전송**: 수신자 수, 전송 결과와 함께 INFO 로그
- [ ] **전송 실패**: 실패 원인과 재시도 정보 포함하여 WARN/ERROR 로그
- [ ] **성능 추적**: 메시지 처리 시간, DB 저장 시간 측정

#### WebRTC 시그널링 로직

- [ ] **시그널링 시작**: SDP/ICE 교환 시작 시 INFO 로그
- [ ] **시그널링 완료**: 교환 완료 시 처리 시간과 함께 INFO 로그
- [ ] **연결 실패**: 시그널링 실패 시 상세 원인과 함께 ERROR 로그
- [ ] **상태 추적**: 영상방 참가자 변화 시 INFO 로그

### 🗄️ 데이터베이스 작업 시

#### 쿼리 실행

- [ ] **쿼리 시작**: 쿼리 타입과 주요 파라미터 DEBUG 로그
- [ ] **쿼리 완료**: 실행 시간과 영향받은 행 수 DEBUG 로그
- [ ] **쿼리 실패**: SQL 에러와 파라미터 포함하여 ERROR 로그
- [ ] **성능 모니터링**: 느린 쿼리(100ms 이상) WARN 로그

#### 트랜잭션 관리

- [ ] **트랜잭션 시작**: 트랜잭션 범위 DEBUG 로그
- [ ] **커밋/롤백**: 트랜잭션 결과와 이유 INFO 로그
- [ ] **데드락**: 데드락 발생 시 관련 정보와 함께 ERROR 로그

### 🌐 네트워크 통신 시

#### 소켓 통신

- [ ] **연결 수락**: 클라이언트 IP와 포트 정보 INFO 로그
- [ ] **연결 해제**: 해제 원인과 세션 정보 INFO 로그
- [ ] **통신 오류**: 소켓 에러와 연결 상태 ERROR 로그
- [ ] **타임아웃**: 타임아웃 발생 시 설정값과 함께 WARN 로그

#### 메시지 송수신

- [ ] **메시지 송신**: 메시지 크기와 대상 정보 DEBUG 로그
- [ ] **메시지 수신**: 발신자와 메시지 타입 정보 DEBUG 로그
- [ ] **파싱 오류**: JSON 파싱 실패 시 원본 메시지 일부 포함 ERROR 로그

### 🔒 보안 관련 로직

#### 인증/인가

- [ ] **로그인 시도**: 사용자 ID와 시도 결과 INFO 로그
- [ ] **권한 확인**: 요청된 권한과 확인 결과 DEBUG 로그
- [ ] **접근 거부**: 거부 원인과 사용자 정보 WARN 로그
- [ ] **보안 위반**: 의심스러운 활동 시 상세 정보 ERROR 로그

#### 민감 정보 처리

- [ ] **데이터 마스킹**: 비밀번호, 토큰 등 민감 정보 마스킹 확인
- [ ] **개인정보 보호**: 이메일, 전화번호 등 부분 마스킹 적용
- [ ] **로그 레벨 확인**: 민감 정보가 포함된 로그의 적절한 레벨 설정

### 📊 성능 모니터링

#### 응답 시간 측정

- [ ] **처리 시간**: 주요 비즈니스 로직의 실행 시간 측정
- [ ] **임계값 확인**: 설정된 임계값 초과 시 WARN 로그
- [ ] **병목 지점**: 성능 병목이 예상되는 지점에 측정 로그
- [ ] **리소스 사용량**: 메모리, CPU 사용량이 높을 때 모니터링 로그

#### 비즈니스 메트릭

- [ ] **사용자 활동**: 활성 사용자 수, 세션 시간 등 측정
- [ ] **메시지 통계**: 전송 성공률, 평균 응답 시간 등 측정
- [ ] **에러율**: 시간대별 에러 발생률 추적
- [ ] **시스템 상태**: 전체 시스템 건강도 지표 로그

### 🧪 테스트 및 디버깅

#### 개발 환경

- [ ] **테스트 데이터**: 테스트용 데이터 사용 시 명확히 표시
- [ ] **디버그 정보**: 개발 시 필요한 상세 정보 TRACE/DEBUG 로그
- [ ] **모의 객체**: Mock 객체 사용 시 실제 호출과 구분하여 로그

#### 프로덕션 준비

- [ ] **로그 레벨 검토**: 프로덕션에서 불필요한 DEBUG 로그 제거
- [ ] **성능 영향**: 로깅으로 인한 성능 저하 최소화
- [ ] **로그 순환**: 로그 파일 크기 관리 설정 확인
- [ ] **모니터링 연동**: 로그 분석 도구와의 연동 확인

### 📋 코드 리뷰 시 확인사항

#### 로그 품질

- [ ] **메시지 명확성**: 로그 메시지만으로 상황 파악 가능한지 확인
- [ ] **컨텍스트 충분성**: 디버깅에 필요한 정보가 충분히 포함되었는지 확인
- [ ] **일관성**: 프로젝트 전체의 로그 패턴과 일치하는지 확인
- [ ] **적절성**: 로그 레벨이 메시지의 중요도와 일치하는지 확인

#### 보안 및 성능

- [ ] **민감 정보**: 민감한 정보가 노출되지 않는지 확인
- [ ] **성능 영향**: 과도한 로깅으로 인한 성능 저하 없는지 확인
- [ ] **예외 처리**: 모든 예외가 적절히 로깅되는지 확인
- [ ] **리소스 관리**: 로그 관련 리소스가 적절히 관리되는지 확인

---

## 🎯 로그 작성 우선순위

### 🔴 높은 우선순위 (반드시 포함)

1. **에러 및 예외 상황**: 모든 예외는 반드시 로깅
2. **사용자 세션 관리**: 연결/해제, 인증 결과
3. **비즈니스 핵심 이벤트**: 메시지 전송, 채팅방 생성 등
4. **보안 관련 이벤트**: 인증 실패, 권한 위반 등

### 🟡 중간 우선순위 (권장)

1. **성능 메트릭**: 응답 시간, 처리량 측정
2. **상태 변화**: 중요 객체의 상태 변경
3. **외부 시스템 연동**: DB, API 호출 결과
4. **설정 및 초기화**: 시스템 시작/종료 과정

### 🟢 낮은 우선순위 (선택적)

1. **상세 디버그 정보**: 개발 시에만 필요한 정보
2. **내부 로직 추적**: 복잡한 알고리즘의 중간 과정
3. **성능 최적화 정보**: 세밀한 성능 튜닝용 데이터
4. **통계 및 분석**: 비즈니스 인텔리전스용 데이터

- [ ] 성능 측정이 필요한 구간 로깅
- [ ] 사용자 식별 정보 포함

### 에러 처리 시

- [ ] 에러 발생 컨텍스트 정보 포함
- [ ] 스택 트레이스 포함 (ERROR 레벨)
- [ ] 복구 가능한 에러는 WARN 레벨 사용
- [ ] 사용자 영향도 고려한 로그 레벨 선택

---

**목표**: 실행흐름 추적과 디버깅 효율성 극대화  
**핵심**: 적절한 로그 레벨 + 상세한 컨텍스트 정보 + 일관된 형식  
**결과**: 빠른 문제 해결 + 안정적인 서버 운영

> 이 로그 작성 규칙을 따라 ASSA Chat Server의 복잡한 실행 흐름을 명확하게 추적하고, 문제 발생 시 신속한 디버깅을 수행할 수 있습니다.
